一、剑指 Offer 09. 用两个栈实现队列

coding:
class CQueue {
    //利用linkedList充当栈
    LinkedList<Integer> A,B;
    public CQueue() {
        A=new LinkedList<Integer>();
        B=new LinkedList<Integer>();
        //new 对象构造A,B两个实例，A为主栈，B为辅助栈           
    }
    
    public void appendTail(int value) {
        A.add(value);//直接在主栈尾部插入元素实现队列尾部插入整数

    }
    
    public int deleteHead() {
        //当辅助栈还有整数时，删除辅助栈的数
        //当辅助栈没有了，需要将A的首位转移到B的末尾
        //当主栈没有了，所以队列没有元素了，返回-1
        if(!B.isEmpty()){
            return B.removeLast();
        }
        if(A.isEmpty()){
            return -1;
        }
        if(!A.isEmpty()){
            B.add(A.poll());
        }
        return B.removeFirst();
        
    }
       
}

二、剑指 Offer 30. 包含min函数的栈

coding:
class MinStack {

    /** initialize your data structure here. */
    //考虑到min()方法要求时间复杂度为O（1），使用辅助栈存储，同样使用LinkedList
    LinkedList<Integer> A,B;
    public MinStack() {
        A=new LinkedList<>();
        B=new LinkedList<>();
    }
    
    public void push(int x) {
        A.add(x);//在主栈末尾添加
        /*if(!B.isEmpty()){
            if(B.getFirst()>=x) B.addFirst(x);
        }
        */
        if(B.isEmpty()||B.getFirst()>=x) B.addFirst(x);
        
    }
    
    public void pop() {
        if(A.removeLast().equals(B.peek())) B.removeFirst();

    }
    
    public int top() {//top实际上是查看栈顶的元素，并没有删除元素，注意理解题目
        return A.getLast();


    }
    
    public int min() {//min实际也没有删除元素
        return B.getFirst();

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
 
 三、1.两数字和
 
 coding:
 
 class Solution {
    public int[] twoSum(int[] nums, int target) {
        //对数组排序
        Arrays.sort(nums);
        int [] res=new int[2];
        //双指针
        int left=0;
        int right=nums.length-1;
        while(left<right){
            if(nums[left]+nums[right]>target) right--;
            else if(nums[left]+nums[right]<target) left++;
            else {
                res[0]=left;
                res[1]=right;
            }
        }
        return res;
    }
}

上述方法显示超时

method 2:

class Solution {
    public int[] twoSum(int[] nums, int target) {
        //利用HashMap存储数据
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])) return new int[] {map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int [2];
    }
}

四、剑指offer24 反转链表

coding:

class Solution {
    public ListNode reverseList(ListNode head) {
        //双指针，如果node没有赋值那么就类似于指针
        ListNode cur=head;
        ListNode pre=null;//指向尾端
        while(cur!=null){//遍历链表
            ListNode temp=cur.next;
            cur.next=pre;//第一次时头结点指向null
            pre=cur;
            cur=temp;//开始遍历
        }
        return pre;
    }
}

递归

class Solution {
    public ListNode reverseList(ListNode head) {
        return recur(head, null);    // 调用递归并返回
    }
    private ListNode recur(ListNode cur, ListNode pre) {
        if (cur == null) return pre; // 终止条件
        ListNode res = recur(cur.next, cur);  // 递归后继节点
        cur.next = pre;              // 修改节点引用指向
        return res;                  // 返回反转链表的头节点
    }
}

五、剑指offer 06 从尾到头打印链表

coding:
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode cur=head;
        LinkedList<Integer> list=new LinkedList<>();
        while(cur!=null){
            list.addFirst(cur.val);
            cur=cur.next;
        }
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.get(i);
        }
        return res;
    }
}

该方法时间耗费较大，需要调整算法，原因在于对linkedList进行了查找，增加了时间复杂度，可修改为：
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode cur=head;
        LinkedList<Integer> list=new LinkedList<>();
        while(cur!=null){
            list.addFirst(cur.val);
            cur=cur.next;
        }
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.removeFirst();
        }
        return res;
    }
}

使用递归算法：
class Solution {
    List<Integer> list=new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        recur(head);
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.get(i);
        }
        return res;
    }
    void recur(ListNode head){
        if(head==null) return;
        recur(head.next);
        list.add(head.val);
    }
}

六、剑指offer 35复杂链表的复制

coding:

class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;//排除特殊情况
        Map<Node,Node> map=new HashMap<Node,Node>();
        Node cur=head;
        while(cur!=null){
            map.put(cur,new Node(cur.val));//建立新旧链表映射
            cur=cur.next;
        }
        cur=head;//回到头结点
        while(cur!=null){//复制next与random
            map.get(cur).next=map.get(cur.next);//新链表当前节点cur指向其cur.next
            map.get(cur).random=map.get(cur.random);
            cur=cur.next;
        }
        return map.get(head);
        
    }
}

七、左旋转字符串

coding:
class Solution {
    public String reverseLeftWords(String s, int n) {
        //return s.substring(n)+s.substring(0,n);
        //StringBuilder
        StringBuilder builder=new StringBuilder();
        for(int i=n;i<s.length();i++) builder.append(s.charAt(i));
        for(int i=0;i<n;i++) builder.append(s.charAt(i));
        return builder.toString();
    }
}

八、剑指offer 05 替换空格

coding:

class Solution {
    public String replaceSpace(String s) {
        StringBuilder res=new StringBuilder();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==' '){
                res.append("%20");
                continue;
            }
            res.append(s.charAt(i));
        }
        return res.toString();
    }
}

九、剑指offer 03 数组中重复的数字

coding:
class Solution {
    public int findRepeatNumber(int[] nums) {
        //由于数组长度为n，所有数字均在0-n-1内，因此可以考虑将数字对应数组下标，若重复则有多出来的数字
        /*
        for(int i=0;i<nums.length;i++){
            if(nums[i]==i) continue;
            else if (nums[i]==nums[nums[i]]) return nums[i];
            while(nums[i]!=i){
                int temp=nums[i];
                nums[i]=nums[nums[i]];//注意这里实际上算法有问题，nums[i]数值已调整
                nums[nums[i]]=temp;//这里并没有做到两坐标下数值交换
            }
            

        }
        return -1;
        */
        
    }
}
以上方法超出时间，两层循环O(N2）
修改为：
class Solution {
    public int findRepeatNumber(int[] nums) {
        //由于数组长度为n，所有数字均在0-n-1内，因此可以考虑将数字对应数组下标，若重复则有多出来的数字

        int i=0;
        while (i<nums.length){
            if(nums[i]==i) {
                i++;
                continue;
            }else if(nums[i]==nums[nums[i]]) return nums[i];
            int temp=nums[i];
            nums[i]=nums[temp];
            nums[temp]=temp;

        }
        return -1;
      
    }
}

十、剑指offer 53 在排序数组中查找数字
coding:
class Solution {
    public int search(int[] nums, int target) {
        //两次二分法，以目标数值为界，左边为小于目标数值的左区间，右边为大于目标数值的右区间
        int i=0;
        int j=nums.length-1;
        if(nums.length==0||target<nums[i]||target>nums[j]) return 0;
        int temp=0;
        while(i<j){//i==j时停止循环右边界
            int mid=i+(j-i+1)/2;
            if(target<nums[mid]){
                j=mid-1;
            }else{
                i=mid;
            }
        }
        if(nums[i]==target){
            temp=i;
            i=0;
            j=nums.length-1;
        }else {
            return 0;
        }
        while(i<j){//i==j时停止循环左边界
            int mid=i+(j-i)/2;
            if(target>nums[mid]){
                i=mid+1;
            }else{
                j=mid;
            }

        }
        return temp-j+1;

    }
}

十一、剑指offer 53 0-n-1中缺失的数字
coding:
class Solution {
    public int missingNumber(int[] nums) {
        //一次二分法，以目标数值为界，左边为数组下标与值相等的左区间，右边为数组下标小于目标数值的右区间
        int i=0;
        int j=nums.length-1;
        while(i<=j){//i>j时停止循环
            int mid=i+(j-i)/2;
            if(mid==nums[mid]){
                i=mid+1;
            }else{
                j=mid-1;
            }
        }
        
        return i;
    }
}

十二、剑指offer 04 二维数组中的查找
coding:
//参考题解的思路，类似二叉搜索树
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        //以左下角为基准点
        int line=matrix.length-1;
        int column=0;
        while(line>=0&&column<matrix[0].length){//在自己写的过程中将&&写成了||，实际情况只有当两者均满足时才能继续循环
            if(target>matrix[line][column]){
                column++;
            }else if(target<matrix[line][column]){
                line--;
            }else{
                return true;
            }
        }
        return false;
    }
}

十三、剑指offer 11 旋转数组的最小数字
coding:

class Solution {
    public int minArray(int[] numbers) {
        //二分法，左区间为升序数组，最后一位为原数组最大值，右区间也为升序数组，第一位即为数组最小值
        if(numbers.length==0) return 0;
        if(numbers.length==1) return numbers[0];

        int left=0;
        int len=numbers.length;
        int right=len-1;
        while(left<right){//当left=right时跳出循环
            int mid=left+(right-left)/2;
            //如果mid>right,说明mid当前在左区间，目标值下标必然大于mid
            //如果mid>right，说明mid当前在右区间，目标值下标小于等于mid
            //如果Mid=right，说明数组只有两个数，目标值下标小于等于mid(这里思路有问题，因为数组中存在重复值)
            if(numbers[mid]>numbers[right]){
                left=mid+1;
            }else if(numbers[mid]<numbers[right]){
                right=mid;
            }else{
                right--;//想法很巧妙，缩小搜索区间
            }

        }
        return numbers[left];

    }
}

十四、剑指offer 50 第一个只出现一次的字符
coding:
class Solution {
    public char firstUniqChar(String s) {
        //利用HashMap记录
        Map<Character,Boolean>map=new HashMap<>();//自己思维混乱，没想出来，参考题解
        char [] ch=s.toCharArray();
        for(int i=0;i<ch.length;i++){
            map.put(ch[i],!map.containsKey(ch[i]));          
        }
        for(int i=0;i<ch.length;i++){
            if(map.get(ch[i])) return ch[i];
        }
        return ' ';
    }
}

十五、剑指offer32-1 从上到下打印二叉树
coding:
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root==null) return new int[0];
        LinkedList<TreeNode> list=new LinkedList<>();//利用LinkedList双端队列的特性存储节点，这一步忘记了，查看了参考题解
        list.add(root);
        List<Integer> res=new ArrayList<>();//记录结果的列表
        while(!list.isEmpty()){
            TreeNode cur=list.poll();
            res.add(cur.val);
            if(cur.left!=null) list.add(cur.left);
            if(cur.right!=null) list.add(cur.right);
        }
        int [] out=new int[res.size()];
        for(int i=0;i<out.length;i++){
            out[i]=res.get(i);
        }
        return out;
    }
}

十六、剑指offer32-2，从上到下打印二叉树
coding:
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<>();
        List<List<Integer>> res=new ArrayList<>();//参考了题解
        LinkedList<TreeNode> list=new LinkedList<>();
        list.add(root);
        while(!list.isEmpty()){
            List<Integer> temp=new ArrayList<>();//将每行的元素存储在temp中
            for(int i=list.size();i>0;i--){//初始化循环式i已定，因此循环次数已定，即使因为添加cur.left/right而导致List长度发生了变化
                TreeNode cur=list.poll();
                temp.add(cur.val);
                if(cur.left!=null) list.add(cur.left);
                if(cur.right!=null) list.add(cur.right);
            }
            res.add(temp);
        }
        return res;
    }
}

十七、剑指offer32-3 从上到下打印二叉树
coding:
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<>();
        List<List<Integer>> res=new ArrayList<>();
        LinkedList<TreeNode> list=new LinkedList<>();
        list.add(root);
        int flag=0;
        while(!list.isEmpty()){
            LinkedList<Integer> temp=new LinkedList<>();//将每行的元素存储在temp中
            for(int i=list.size();i>0;i--){//初始化循环式i已定，因此循环次数已定，即使因为添加cur.left/right而导致List长度发生了变化
                if(flag%2==0){
                    TreeNode cur=list.poll();
                    temp.addLast(cur.val);
                    if(cur.left!=null) list.add(cur.left);
                    if(cur.right!=null) list.add(cur.right);
                }else{
                    TreeNode cur=list.poll();
                    temp.addFirst(cur.val);
                    if(cur.left!=null) list.add(cur.left);
                    if(cur.right!=null) list.add(cur.right);
                }
                
            }
            flag++;
            res.add(temp);
        }
        return res;
    }
}

十八、剑指offer27 二叉树的镜像
coding:
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        //自己没有解出来，理解题解后写出
        //辅助栈法
        if(root==null) return null;
        LinkedList<TreeNode> list=new LinkedList<>();
        list.add(root);
        while(!list.isEmpty()){//利用栈对二叉树进行遍历，从而交换节点
            TreeNode cur=list.removeLast();
            if(cur.left!=null) list.add(cur.left);
            if(cur.right!=null) list.add(cur.right);
            TreeNode temp=cur.left;
            cur.left=cur.right;
            cur.right=temp;
        }
        return root;
    }
    
}
递归法：
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        //自己没有解出来，理解题解后写出
       
        //递归
        if(root==null) return null;
        TreeNode leftNode=mirrorTree(root.left);
        TreeNode rightNode=mirrorTree(root.right);
        root.right=leftNode;
        root.left=rightNode;
        return root;

    }
    
}

十九、剑指offer28 对称的二叉树
coding:
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //参考题解递归深度优先算法从上至下
        if(root==null) return true;
        return recur(root.left,root.right);
    }
    public boolean recur(TreeNode A,TreeNode B){
        //递归结束条件：如果左右叶子节点均为空，说明同时跳出则返回true
        //如果其中之一先结束或者左边不等于右边，则返回false
        if(A==null&&B==null) return true;
        if(A==null||B==null||A.val!=B.val) return false;
        return recur(A.left,B.right)&&recur(A.right,B.left);

    }
}

二十、剑指offer26 树的子结构
coding:
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A==null||B==null) return false;
        //三种情况：
        //B节点是A节点的子结构，
        //B节点是A左节点的子结构
        //B节点是A右节点的子结构，任意一种成立即返回true
        if(recur(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B)) return true;

        return false;
    }
    public boolean recur(TreeNode A,TreeNode B){
        if(B==null) return true;//如果B遍历结束了，说明前面的递归都为true，没有问题，返回true；
        if(A==null) return false;//如果A遍历结束了，说明B仍有节点，则为false;
        if(A.val==B.val){
            return recur(A.left,B.left)&&recur(A.right,B.right);
        }else{
            return false;
        }
    }
}

二十一、剑指offer 18 删除链表的节点
coding(有误）:
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode cur=head;
        ListNode pre=new ListNode(0);
        while(cur!=null){
            ListNode temp=cur.next;
            if(cur.val==val){//解决不了删除数字为首位的问题
                pre.next=temp;   
                cur.next=null;
            }
            pre=cur;
            cur=temp;
        }
        return head;
    }
}

参考题解发现将特例提出即可：
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode cur=head;
        ListNode pre=new ListNode(0);
        if(head.val == val) return head.next;//特例
        while(cur!=null){
            ListNode temp=cur.next;
            if(cur.val==val){//解决不了删除数字为首位的问题
                pre.next=temp;   
                cur.next=null;
            }
            pre=cur;
            cur=temp;
        }
        return head;
    }
}

题解没有考虑头结点：
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if(head.val == val) return head.next;
        ListNode pre = head, cur = head.next;
        while(cur != null && cur.val != val) {
            pre = cur;
            cur = cur.next;
        }
        if(cur != null) pre.next = cur.next;
        return head;
    }
}


二十二、剑指offer 22 链表中倒数第k个节点
coding:
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        //两次遍历
        ListNode cur1=head;
        ListNode cur2=head;

        int flag=0;
        while(cur1!=null){
            flag++;
            cur1=cur1.next;
        }
        for(int i=1;i<=flag-k;i++){
            cur2=cur2.next;
        }
        return cur2;
    }
}
二十三、剑指offer 52 两个链表的第一个公共节点
coding:
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null||headB==null) return null;
        //根据题解参考
        ListNode A=headA;
        ListNode B=headB;
        while(A!=B){
            if(A!=null) {
               A=A.next; 
            }else{
                A=headB;
            };
            if(B!=null) {
                B=B.next;
            }else{
               B=headA; 
            }
            
        }
        return A;

    }
}

二十四、剑指offer 25合并两个排序的链表

coding:
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //根据题解编写
        //使用一个新的链表作为合并链表
        ListNode res=new ListNode(0);//头结点
        ListNode cur=res;
        while(l1!=null&&l2!=null){
            if(l1.val>l2.val){
                cur.next=l2;
                l2=l2.next;
            }else{
                cur.next=l1;
                l1=l1.next;
            }
            cur=cur.next;
        }
        while(l1!=null){
            cur.next=l1;
            l1=l1.next;
            cur=cur.next;
        }
        while(l2!=null){
            cur.next=l2;
            l2=l2.next;
            cur=cur.next;
        }
        return res.next;

    }
}

二十五、剑指offer 21调整数组顺序使奇数位于偶数前面
coding:
class Solution {
    public int[] exchange(int[] nums) {
        //双指针
        int left=0;
        int right=nums.length-1;
        while(left<right){
            while(left<right&&nums[left]%2!=0){//注意left<right这个限制条件，可避免越界
                left++;
            }
            while(left<right&&nums[right]%2==0){//注意left<right这个限制条件，可避免越界
                right--;
            }
            int temp=nums[left];
            nums[left]=nums[right];
            nums[right]=temp;
            left++;
            right--;
        }
        return nums;
    }
}

二十六、剑指offer 57 和为s的两个数
coding:
class Solution {
    public int[] twoSum(int[] nums, int target) {
        //双指针
        int left=0;
        int right=nums.length-1;
        int [] res=new int[2];
        while(left<right){
            while(nums[left]+nums[right]>target){
                right--;
            }
            while(nums[left]+nums[right]<target){
                left++;
            }
            if(nums[left]+nums[right]==target){
                res[0]=nums[left];
                res[1]=nums[right];
                return res;
            } 
        }
        return null;
    }
}

二十七、剑指offer 58-1 翻转单词顺序
coding:
class Solution {
    public String reverseWords(String s) {
        s=s.trim();//清除首尾两端的空格
        //char[] ch=s.toCharArray();
        StringBuilder res=new StringBuilder();
        int right=s.length()-1;
        int i=s.length()-1;
        while(i>=0){
            while(i>=0&&s.charAt(i)!=' '){
                i--; 
            }
            res.append(s.substring(i+1,right+1));
            res.append(' ');
            while(i>=0&&s.charAt(i)==' '){
                i--;
            }
            right=i;
        }       
        return res.toString().trim();
    }
}

二十八、剑指offer 61 扑克牌中的顺子
coding:
class Solution {
    public boolean isStraight(int[] nums) {
        Arrays.sort(nums);
        int i=0;
        for(int j=0;j<nums.length;j++){
            if(nums[j]==0) continue;
            if(j<nums.length-1&&nums[j]==nums[j+1]) return false;
        }
        while(i<nums.length){
            while(nums[i]==0)i++;
            if(nums[nums.length-1]-nums[i]<5){
                return true;
            }
        }
        return false;
    }
}
自己的思路但是两次遍历超时了
参考题解：
class Solution {
    public boolean isStraight(int[] nums) {
        Arrays.sort(nums);
        int joker=0;
        for(int i=0;i<4;i++){
            if(nums[i]==0) joker++;
            else if(nums[i]==nums[i+1]) return false;
        }
        if(nums[4]-nums[joker]<5) return true;
        return false;
    }
}

二十九、对链表进行插入排序
coding:
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode cur=head;
        ListNode pre=new ListNode(Integer.MIN_VALUE);//头结点的前节点
        pre.next=head;

        //遍历链表
        while(cur.next!=null){//因为需要比较cur.next与cur的大小
            if(cur.val>cur.next.val){
                ListNode temp=cur.next;//暂存这个较小值
                cur.next=temp.next;//将cur指向cur.next.next，删除cur.next
                ListNode firstHead=head;//遍历起始点
                ListNode preHead=pre;
                preHead.next=firstHead;
                if(temp.val<=firstHead.val){
                    pre.next=temp;
                    temp.next=firstHead;
                }
                while(temp.val>firstHead.val){
                    firstHead=firstHead.next;
                    preHead=preHead.next;
                }
                preHead.next=temp;
                temp.next=firstHead;
            }else{
                cur=cur.next;
            }
            
        }
        return pre.next;
    }
}
执行错误，需要调整代码,根据题解调整后：
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if(head == null){//别忘记判空
            return head;
        }
        ListNode cur=head;
        ListNode pre=new ListNode(Integer.MIN_VALUE);//头结点的前节点
        pre.next=head;
        ListNode curr=cur.next;

        //遍历链表
        while(curr!=null){//因为需要比较cur.next与cur的大小
            if(cur.val>curr.val){
                /*ListNode temp=cur.next;//暂存这个较小值
                cur.next=temp.next;//将cur指向cur.next.next，删除cur.next
                ListNode firstHead=head;//遍历起始点
                ListNode preHead=pre;
                preHead.next=firstHead;
                if(temp.val<=firstHead.val){
                    pre.next=temp;
                    temp.next=firstHead;
                }
                while(temp.val>firstHead.val){
                    firstHead=firstHead.next;
                    preHead=preHead.next;
                }
                preHead.next=temp;
                temp.next=firstHead;
                */
                ListNode preNode=pre;//要点就在于这个引用
                while(preNode.next.val<=curr.val){
                    preNode=preNode.next;
                }
                cur.next=curr.next;
                curr.next=preNode.next;
                preNode.next=curr;
            }else{
                cur=cur.next;
            }
            curr=cur.next;
            
        }
        return pre.next;
    }
}

三十、合并两个有序数组
coding:
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //特殊情况
        if(m==0){
            for(int i=0;i<=n;i++){
                nums1[i]=nums2[i];
            }
            return;
        }
        else if(n==0) return;
        else if(m==0&&n==0) return ;
        //组合数组
        //借助另外一个数组空间拷贝nums1
        //System.arraycopy(nums, left, temp, left, right + 1 - left);
        int [] temp=new int[m+n];
        //System.arraycopy(nums1,0,temp,0,m+1);
        int i=0,j=0;
        for(int k=0;k<=temp.length;k++){
            if(i==m+1){
                temp[k]=nums2[j];
                j++;
            }else if(j==n+1){
                temp[k]=nums1[i];
                i++;
            }else if(temp[i]<=nums2[j]){
                temp[k]=nums1[i];
                i++;
            }else{
                temp[k]=nums2[j];
                j++;
            }
            //return;
        }
        for(int h=0;h<=temp.length;h++){
            nums1[h]=temp[h];
        }
        return;
    }
}
结果显示报错，数组越界，可能是j越界了,参考题解
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //特殊情况
        if(m==0){
            for(int i=0;i<n;i++){
                nums1[i]=nums2[i];
            }
            return;
        }
        else if(n==0) return;
        else if(m==0&&n==0) return ;
        //组合数组
        int [] temp=new int[m+n];借助临时数组存储
        int i=0,j=0;
        int res=0;//借助临时变量存储
        while(i<m||j<n){
            if(i==m){
                res=nums2[j];
                j++;
            }else if(j==n){
                res=nums1[i];
                i++;
            }else if(nums1[i]<=nums2[j]){
                res=nums1[i];
                i++;
            }else{
                res=nums2[j];
                j++;
            }
            temp[i+j-1]=res;
        }
        for(int h=0;h<temp.length;h++){
            nums1[h]=temp[h];
        }
        return;
    }
}

三十一、数组中的逆序对
coding:

class Solution {
    public int reversePairs(int[] nums) {
        //归并排序的变化
        int []temp=new int[nums.length];
        return merge(nums,0,nums.length-1,temp);

    }

    public int merge(int [] nums,int left,int right,int [] temp){
        if(left==right) return 0;//递归需要结束条件
        int mid=(right+left)/2;
        int res=merge(nums,left,mid,temp)+merge(nums,mid+1,right,temp);
        int lStart=left;
        int rStart=mid+1;
        for (int k = left; k <= right; k++)
            temp[k] = nums[k];
        for(int k=left;k<=right;k++){
            if(lStart==mid+1){
                nums[k]=temp[rStart];
                rStart++;
            }else if(rStart==right+1){
                nums[k]=temp[lStart];
                lStart++;
            }else if(nums[lStart]<=nums[rStart]){
                nums[k]=temp[lStart];
                lStart++;
            }else{
                
                nums[k]=temp[rStart];
                rStart++;
                res+=mid-lStart+1;
                
            }
        }
        return res;
    }
}

结果执行出错，但没找到原因


三十二、剑指 offer 15 二进制中1的个数
coding:
基础薄弱，参考题解学习
coding 1:
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res=0;
        while(n!=0){
            res+=n&1;
            n>>>=1;
        }
        return res;
    }
}

coding 2:
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res=0;
        while(n!=0){
            res+=1;
            n=n&(n-1);
        }
        return res;
    }
}
n&(n-1)的思路很棒，可以很好的定位1
另外一个例子：
三十三、2的幂
coding:
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n>0 && (n & (n-1))==0;
    }
}

三十四、剑指offer 65 不用加减乘除做加法
coding:
基础薄弱，参考题解学习
coding:
class Solution {
    public int add(int a, int b) {
        while(b!=0){
            int c=(a&b)<<1;//进位和
            a=a^b;//无进位和
            b=c;
        }
        return a;
    }
}

三十五、剑指offer 56-I 数组中数字出现的次数
coding:
基础薄弱，参考题解学习
class Solution {
    public int[] singleNumbers(int[] nums) {
        //根据题解作答
        int res=0;
        for(int num:nums){//遍历数组对所有数字进行异或运算
            res=res^num;//此时应当为目标两个数字的异或结果
        }
        int temp=1;//用于下一步进行与运算将两个数字的异或结果拆分
        while((temp&res)==0){//注意==优先级高于&需要添加括号保证运算顺序
            temp<<=1;//当temp&res==1时，表示res此时位置的值为1，说明找到了目标两个数字异或结果从右外左的第一个不同值的位置，不再左移
        }
        int a=0;
        int b=0;
        for(int num:nums){
            if((temp&num)==0){//将确定的位置与遍历的数字通过与运算进行分组，因为该位置目标的两个数字的值也不同，可将其分开，两组中各有一个数字，而每组其他的数字均存在两次，再次异或运算后每组均剩下目标数字
                a=a^num;
            }else{
                b=b^num;
            }
        }
        int sum[]=new int[]{a,b};
        return sum;

    }
}

三十六、215.数组中的第K个最大元素
coding:
快速排序学习

import java.util.Random;
class Solution {
    private static Random random = new Random(System.currentTimeMillis());
    public int findKthLargest(int[] nums, int k) {
        int len=nums.length;
        int left=0;
        int right=len-1;
        
        //开始循环缩减区间
        while(true){
            int index=partition(nums,left,right);
            if(index>len-k){
                right=index-1;
            }else if(index<len-k){
                left=index+1;
            }else{
                return nums[index];
            }
        }
    }
    //封装转换方法
    public void swap(int []nums,int left,int right){
        int temp=nums[left];
        nums[left]=nums[right];
        nums[right]=temp;
    }
    //减治方法
    public int partition(int []nums,int left,int right){
        if(right>left){
            int index1=left+1+random.nextInt(right-left);
            swap(nums,left,index1);
        }
        int refer=nums[left];
        int j=left;
        for(int i=left+1;i<=right;i++){
            if(nums[i]<refer){
                j++;
                swap(nums,i,j);
            }
        }
        //循环是保证数组区间[left+1,j]值都小于refer,[j+1,i]值都大于等于refer
        //下面代码则使得区间[left,j-1]值都小于refer,j的值refer,[j,right]的值大于等于refer
        swap(nums,left,j);
        return j;

    }
}

三十七、两数之和
暴力解法：
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int len=nums.length;
        for(int i=0;i<len;i++){
            for(int j=i+1;j<len;j++){
                if(nums[i]+nums[j]==target){
                    return new int []{i,j};
                }
            }
        }
        return null;
    }
}

HashMap:
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int len=nums.length;
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<len;i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]),i};
            }
            map.put(nums[i],i);
        }
        return null;
    }
}
三十八、两数相加
coding:

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode res=new ListNode(0);//构造一个用于装和的链表
        ListNode cur=res;//给一个指针用于移动
        int carry=0;//进位值
        while(l1!=null||l2!=null){
            int x=l1==null?0:l1.val;
            int y=l2==null?0:l2.val;
            int sum=x+y+carry;//求和
            carry=sum>9?1:0;
            sum=sum%10;
            cur.next=new ListNode(sum);//将链表下一位指向带值的节点
            cur=cur.next;//移动到下一个节点
            if(l1!=null){
                l1=l1.next;
            }
            if(l2!=null){
                l2=l2.next;
            }           

        }
        if(carry==1){
            cur.next=new ListNode(carry);
        }

        return res.next;
    }
}

三十九、无重复字符的最长子串

coding:
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> map=new HashMap<>();
        int res=0;
        int left=0;
        for(int i=0;i<s.length();i++){
            while(map.containsKey(s.charAt(i))){
                map.remove(s.charAt(left));
                left++;
            }
            map.put(s.charAt(i),i);
            res=Math.max(res,i-left+1);
        }
        return res;
    }
}
查看题解，修改了一行代码节约了2s
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> map=new HashMap<>();
        int res=0;
        int left=0;
        for(int i=0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                left=Math.max(left,map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            res=Math.max(res,i-left+1);
        }
        return res;
    }
}
四十、寻找两个正序数组的中位数
coding:
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        //归并排序
        int len1=nums1.length;
        int len2=nums2.length;
        int [] arr=new int[len1+len2];
        int i=0;
        int j=0;
        int k=0;
        double res=0.0;
        while(i<len1|j<len2){
            if(i==len1){
                arr[k]=nums2[j];
                k++;
                j++;
            }else if(j==len2){
                arr[k]=nums1[i];
                k++;
                i++;
            }else if(nums1[i]<=nums2[j]){
                arr[k]=nums1[i];
                k++;
                i++;
            }else{
                arr[k]=nums2[j];
                k++;
                j++;
            }
        }
        if((len1+len2)%2==0){
            res=(arr[(len1+len2)/2]+arr[(len1+len2-1)/2])/2.0;
        }else{
            res=arr[(len1+len2)/2];
        }
        
        return res;

    }

}

四十一、接雨水

coding:
class Solution {
   public int trap(int[] height) {
        //按照每列来查看
        int sum=0;
        int leftHeight[]=new int[height.length];
        int rightHeight[]=new int[height.length];
        //获取左边最大列
        for(int j=1;j<height.length-1;j++){
            leftHeight[j]=Math.max(leftHeight[j-1],height[j-1]);
        }
        //获取右边最大列
        for(int j=height.length-2;j>=0;j--){
            rightHeight[j]=Math.max(rightHeight[j+1],height[j+1]);
        }
        for(int i=1;i<height.length-1;i++){
            int min=Math.min(leftHeight[i],rightHeight[i]);
            if(height[i]<min){
                sum+=min-height[i];
            }
        }

        return sum;
    }
}

四十二、最长回文子串

coding:
class Solution {
    public String longestPalindrome(String s) {
        //基础解法，动态规划
        int len=s.length();
        if(len<2) return s;
        char [] temp=s.toCharArray();
        int maxLen=1;
        int begin=0;
        //定义状态方程
        boolean [][] status=new boolean[len][len];
        //初始化状态方程
        for(int i=0;i<len;i++){
            status[i][i]=true;
        }

        //开始遍历
        for(int j=1;j<len;j++){
            for(int i=0;i<j;i++){
                if(temp[i]!=temp[j]) status[i][j]=false;
                else if(j-i<3) status[i][j]=true;
                else status[i][j]=status[i+1][j-1];

                if(status[i][j]&&j-i+1>maxLen){
                    maxLen=j-i+1;
                    begin=i;
                }
            }
        }

        return s.substring(begin,begin+maxLen);
    }
}

coding:
//中心扩散
public class Solution {
    public String longestPalindrome(String s) {
       int len=s.length();
       if(len<2) return s;
       
       int maxLen=1;
       int begin=0;
       
       for(int i=0;i<len-1;i++){
            int oddLen=centroSymmetric(s,i,i);
            int evenLen=centroSymmetric(s,i,i+1);
            int curLen=Math.max(oddLen,evenLen);
            if(curLen>maxLen){
                maxLen=curLen;
                begin=i-(maxLen-1)/2;
            }
            
       }
       return s.substring(begin,begin+maxLen);
       

    }

    public int centroSymmetric(String s,int left,int right){
        while(left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){
            --left;
            ++right;
        }
        return right-1-left;

    }


}

四十三、三数之和

coding:
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        //List<Integer> temp=new ArrayList<>();
        List<List<Integer>> res=new ArrayList<>();
        if(nums.length<3) return res;
        Arrays.sort(nums);
        for(int start=0;start<nums.length-2;start++){
            if(nums[start]>0) break;
            if(start>0&&nums[start]==nums[start-1]) continue;
            int left=start+1,right=nums.length-1;
            while(left<right){
                int sum=nums[start]+nums[left]+nums[right];
                if(sum<0){
                    while(left<right&&nums[left]==nums[++left]);
                }else if(sum>0){
                    while(left<right&&nums[right]==nums[--right]);
                }else{
                    //res.add(new ArrayList<Integer>(Arrays.asList(nums[start], nums[left], nums[right])));
                    List<Integer> temp=new ArrayList<>();
                    temp.add(nums[start]);
                    temp.add(nums[left]);
                    temp.add(nums[right]);
                    res.add(temp);
                    //temp.clear();
                    while(left<right&&nums[left]==nums[++left]);
                    while(left<right&&nums[right]==nums[--right]);
                }
            }
        }

        return res;
    }
}


四十四、爬楼梯

coding:

class Solution {
    public int climbStairs(int n) {
        //动态规划
        int [] dp=new int [n+1];
        if(n<=2) return n;
        dp[1]=1;
        dp[2]=2;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        
        return dp[n];
    }
}

四十五、括号生成

coding:
class Solution {
    public List<String> generateParenthesis(int n) {
        //深度优先算法
        List<String> res=new ArrayList<>();
        if(n==0){
            return res;
        }
        //左括号及右括号还剩多少个的思路
        dfs("",n,n,res);
        return res;

    }

    public void dfs(String src,int left,int right,List<String> res){
        if(left==0&&right==0){
            res.add(src);
            return;
        }
        if(left>right){//由于先生成左括号（有效的），那么剩余右括号应该始终大于左括号的剩余数量，如果小于，则需要剪枝返回
            return;
        }
        if(left>0){
            dfs(src+"(",left-1,right,res);
        }
        if(right>0){
            dfs(src+")",left,right-1,res);
        }

    }
}

四十六、有效的括号
coding:
class Solution {
    public boolean isValid(String s) {
        //使用栈
        //利用hashMap存储括号
        if(s.length()==0){
            return false;
        }
        Map<Character,Character> map=new HashMap<>();
        map.put(')','(');
        map.put(']','[');
        map.put('}','{');
        Stack<Character> stack=new Stack<>();
        char[] temp=s.toCharArray();
        for(int i=0;i<temp.length;i++){
            if(map.containsKey(temp[i])){
                char topElement=stack.empty()?'!':stack.pop();
                if(topElement!=map.get(temp[i])){//如果括号没有正常闭合
                    return false;
                }
            }else{
                stack.push(temp[i]);//将右括号放入栈中
            }
        }
        return stack.empty();

    }
}

四十七、数组中的第K个最大元素

coding:
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int len=nums.length;
        Arrays.sort(nums);
        return nums[len-k];
    }
}

coding:
class Solution {
    public int findKthLargest(int[] nums, int k) {
        //小顶堆
        PriorityQueue<Integer> queue=new PriorityQueue<>();
        for(int i=0;i<nums.length;i++){
            queue.add(nums[i]);
            if(queue.size()>k){
                queue.poll();
            }
        }
        return queue.peek();
    }
}

四十八、括号生成
coding:
class Solution {
    public List<String> generateParenthesis(int n) {
        //深度优先算法
        List<String> res=new ArrayList<>();
        if(n==0){
            return res;
        }
        //左括号及右括号还剩多少个的思路
        dfs("",n,n,res);
        return res;

    }

    public void dfs(String src,int left,int right,List<String> res){
        if(left==0&&right==0){
            res.add(src);
            return;
        }
        if(left>right){//由于先生成左括号（有效的），那么剩余右括号应该始终大于左括号的剩余数量，如果小于，则需要剪枝返回
            return;
        }
        if(left>0){
            dfs(src+"(",left-1,right,res);
        }
        if(right>0){
            dfs(src+")",left,right-1,res);
        }

    }
}

四十九、LRU缓存
这里放一个很好的算法学习网站
https://labuladong.gitee.io/algo/1/3/
coding:
class LRUCache {
    int cap;//缓存最大值
    LinkedHashMap<Integer,Integer> map=new LinkedHashMap<>();//利用LinkedHashMap实现

    public LRUCache(int capacity) {
        this.cap=capacity;
    }
    
    public int get(int key) {
        if(!map.containsKey(key)) return -1;
        makeRecently(key);
        return map.get(key);

    }
    
    public void put(int key, int value) {
        if(map.containsKey(key)){
            map.put(key,value);
            makeRecently(key);
            return;
        }
        if(map.size()>=cap){
            int deleteKey=map.keySet().iterator().next();
            map.remove(deleteKey);
        }
        map.put(key,value);
    }

    public void makeRecently(int key){
        int val=map.get(key);
        map.remove(key);
        map.put(key,val);
    }

}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

五十、盛最多水的容器
coding:
class Solution {
    public int maxArea(int[] height) {
        //双指针
        int i=0,j=height.length-1;
        int maxArea=0;
        while(i<j){
            if(height[i]<=height[j]){
                maxArea=Math.max(height[i]*(j-i),maxArea);
                i++;
            }else{
                maxArea=Math.max(height[j]*(j-i),maxArea);
                j--;
            }
        }
        return maxArea;
    }
}

五十一、合并区间
coding:
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,new Comparator<int[]>(){
            @Override
            public int compare(int[] a,int[] b){
                if(a[0]==b[0]){
                    return a[1]-b[1];
                }else{
                    return a[0]-b[0];
                }
            }
        });
        //Arrays.sort(intervals,(a,b)->(a[0]-b[0]));
        int [][] res=new int [intervals.length][2];
        int index=-1;
        for(int[] num:intervals){
            if(index==-1||num[0]>res[index][1]){//如果遍历的一维数组首位大于结果数组最近的一维数组的末尾
                res[++index]=num;
            }else{//如果遍历的一维数组首位小于结果数组最近的一维数组的末尾，则将结果数组最近一维数组的末位取遍历数组末尾与当前末尾的较大者
                res[index][1]=Math.max(num[1], res[index][1]);
            }
        }
        return Arrays.copyOf(res,index+1);


    }
}
五十二、会议室
coding:
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->(a[0]-b[0]));

        for(int i=0;i<intervals.length-1;i++){
            if(intervals[i+1][0]<intervals[i][1]){
                return false;
            }
        }
        return true;
    }
}
五十三、插入区间
coding:

class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int [][] res=new int [intervals.length+1][2];
        if(intervals.length==0){
            res[0]=newInterval;
            return res;
        }
        int i=0;
        int index=0;
        //1.当newInterval[0]大于数组[1]时，将数组直接添加至res
        //2.当newInterval[0]大于等于数组[0]但小于等于数组[1]时，需要拼接合并数组
        //3.当newInterval数组全部放入res中时，后续intervals的数组全部放入res中
    
            while(i<intervals.length&&newInterval[0]>intervals[i][1]){
                res[index++]=intervals[i++];
            }
            while(i<intervals.length&&newInterval[1]>=intervals[i][0]){
                //题解这里改造newInterval数组
                newInterval[0]=Math.min(intervals[i][0],newInterval[0]);
                newInterval[1]=Math.max(intervals[i][1],newInterval[1]);
                i++;
            }
            res[index++]=newInterval;
            while(i<intervals.length){
                res[index++]=intervals[i++];
            }
            
    
        return Arrays.copyOf(res,index);
    }
}

五十四、删除被覆盖的区间
coding:
class Solution {
    public int removeCoveredIntervals(int[][] intervals) {
        //先排序
        int len=intervals.length;
        Arrays.sort(intervals,(a,b)->(a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));//左升右降
        //int [][] res=new int[intervals.length][2];
        int right=intervals[0][1];
        //如果前后数组的首位数相同时，就会发生两种情况
        //前数组末尾
        for(int i=1;i<intervals.length;i++){
            if(intervals[i-1][0]==intervals[i][0]){
                len--;
            }else if(intervals[i][1]<=right){
                len--;
            }else{
                right=intervals[i][1];
            }

        }
        return len;
    }
}


五十五、汇总区间
coding:
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> res=new ArrayList<>();
        //遍历数组，如果元素连续则开始组建字符串，如果元素不连续，分情况讨论，元素相等和不连续元素（直接加入集合）
        int i=0;
        int len=nums.length;
        while(i<len){
            int low=i;
            i++;
            while(i<len&&nums[i]==nums[i-1]+1){
                i++;
            }
            StringBuilder temp=new StringBuilder();
            temp.append(nums[low]);
            int high=i-1;
            if(high>low){
                temp.append("->");
                temp.append(nums[high]);
            }
            res.add(temp.toString());
        }
        return res;
    }
}

五十六、合并两个有序链表

coding:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode pre=new ListNode(0);
        ListNode cur=pre;
        ListNode p1=list1;
        ListNode p2=list2;
        while(p1!=null&&p2!=null){
            if(p1.val>p2.val){
                cur.next=p2;
                p2=p2.next;
            }else{
                cur.next=p1;
                p1=p1.next;
            }
            cur=cur.next;
        }
        if(p1!=null){
            cur.next=p1;
        }
        if(p2!=null){
            cur.next=p2;
            
        }
        return pre.next;
    }
}

五十七、分隔链表
coding:
class Solution {
    public ListNode partition(ListNode head, int x) {
        //创建两个链表，一个存储小于x的数，另一个存储大于等于x的数
        ListNode list1=new ListNode(0);
        ListNode list2=new ListNode(0);
        ListNode p1=list1;
        ListNode p2=list2;
        ListNode cur=head;
        while(cur!=null){//循环遍历
            if(cur.val>=x){
                p1.next=cur;
                p1=p1.next;
            }else{
                p2.next=cur;
                p2=p2.next;
            }
            ListNode temp=cur.next;
            cur.next=null;//遍历过程中将cur的指针拆掉
            cur=temp;
        }
        p2.next=list1.next;//将存储较小数的链表指向存储较大数的链表
        return list2.next;
    }
}

五十八、删除链表的倒数第N个结点
coding:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(n==0) return head;
        ListNode p1=head;
        ListNode p2=head;
        for(int i=0;i<n;i++){
            p1=p1.next;
        }
        while(p1.next!=null){
            p1=p1.next;
            p2=p2.next;
        }
        ListNode temp=p2.next.next;
        p2.next=temp;
        p2.next.next=null;
        return head;
    }
}
上述自己写的，会报空指针

coding:
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode res=new ListNode(-1);
        res.next=head;
        ListNode temp=fromEnd(res,n+1);
        temp.next=temp.next.next;
        return res.next;
    }
    public ListNode fromEnd(ListNode p,int k){
        ListNode p1=p;
        ListNode p2=p;
        for(int i=0;i<k;i++){
            p1=p1.next;
        }
        while(p1!=null){
            p1=p1.next;
            p2=p2.next;
        }
        return p2;
    }
}

五十九、链表中倒数第k个节点

coding:
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        
        ListNode p1=head;
        for(int i=0;i<k;i++){
            p1=p1.next;
        }
        ListNode p2=head;
        while(p1!=null){
            p1=p1.next;
            p2=p2.next;
        }
        return p2;
        
    }
}


六十、链表的中间结点

coding:
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode p1=head,p2=head;
        while(p1!=null&&p1.next!=null){
            p2=p2.next;
            p1=p1.next.next;
        }
        return p2;
    }
}


六十一、链表中环的入口节点
coding:

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode p1=head,p2=head;
        while(p1!=null&&p1.next!=null){
            p2=p2.next;
            p1=p1.next.next;
            if(p1==p2) break;
        }
        if(p1==null||p1.next==null){//没有环
            return null;
        }
        p2=head;
        while(p2!=p1){
            p2=p2.next;
            p1=p1.next;
        }
        return p2;

    }
}

六十二、在排序数组中查找元素的第一个和最后一个位置
coding:
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        int [] res=new int [2];
        int [] temp={-1,-1};
        //先查找左边界
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                right=mid-1;
            }else if(nums[mid]>target){
                right=mid-1;
            }else if(nums[mid]<target){
                left=mid+1;
            }
        }
        if(left==nums.length) return temp;
        if(nums[left]==target){
            res[0]=left;
        }else{
            return temp;
        }
        left=0;
        right=nums.length-1;
        //查右边界
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]==target){
                left=mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
                
            }else if(nums[mid]<target){
                left=mid+1;
            }
        }
        res[1]=right;
        return res;

    }
}

六十三、爱吃香蕉的珂珂

coding:

class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left=1;
        int right=1000000000;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(f(piles,mid)==h){
                right=mid-1;
            }else if(f(piles,mid)>h){
                left=mid+1;
            }else if(f(piles,mid)<h){
                right=mid-1;
            }
        }
        return left;
    }

    public int f(int [] piles,int k){
        int hour =0;
        for(int i=0;i<piles.length;i++){
            hour+=piles[i]/k;
            //如果没有除尽，那么需要补上1小时将剩余的香蕉吃完
            if(piles[i]%k!=0){
                hour++;
            }
        }
        return hour;
    }
}

代码还差2测试用例没通过

但如果使用左闭右开就可以解决

class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left=1;
        //int right=1000000000;
        // while(left<=right){
        //     int mid=left+(right-left)/2;
        //     if(f(piles,mid)==h){
        //         right=mid-1;
        //     }else if(f(piles,mid)>h){
        //         left=mid+1;
        //     }else if(f(piles,mid)<h){
        //         right=mid-1;
        //     }
        // }
        int right=1000000000+1;
        while(left<right){
            int mid=left+(right-left)/2;
            if(f(piles,mid)==h){
                right=mid;
            }else if(f(piles,mid)>h){
                left=mid+1;
            }else if(f(piles,mid)<h){
                right=mid;
            }
        }
        return left;
    }

    public int f(int [] piles,int k){
        int hour =0;
        for(int i=0;i<piles.length;i++){
            hour+=piles[i]/k;
            //如果没有除尽，那么需要补上1小时将剩余的香蕉吃完
            if(piles[i]%k>0){
                hour++;
            }
        }
        return hour;
    }
}

六十四、在D天内送达包裹的能力
coding :




