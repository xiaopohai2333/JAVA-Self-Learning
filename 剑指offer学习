一、剑指 Offer 09. 用两个栈实现队列

coding:
class CQueue {
    //利用linkedList充当栈
    LinkedList<Integer> A,B;
    public CQueue() {
        A=new LinkedList<Integer>();
        B=new LinkedList<Integer>();
        //new 对象构造A,B两个实例，A为主栈，B为辅助栈           
    }
    
    public void appendTail(int value) {
        A.add(value);//直接在主栈尾部插入元素实现队列尾部插入整数

    }
    
    public int deleteHead() {
        //当辅助栈还有整数时，删除辅助栈的数
        //当辅助栈没有了，需要将A的首位转移到B的末尾
        //当主栈没有了，所以队列没有元素了，返回-1
        if(!B.isEmpty()){
            return B.removeLast();
        }
        if(A.isEmpty()){
            return -1;
        }
        if(!A.isEmpty()){
            B.add(A.poll());
        }
        return B.removeFirst();
        
    }
       
}

二、剑指 Offer 30. 包含min函数的栈

coding:
class MinStack {

    /** initialize your data structure here. */
    //考虑到min()方法要求时间复杂度为O（1），使用辅助栈存储，同样使用LinkedList
    LinkedList<Integer> A,B;
    public MinStack() {
        A=new LinkedList<>();
        B=new LinkedList<>();
    }
    
    public void push(int x) {
        A.add(x);//在主栈末尾添加
        /*if(!B.isEmpty()){
            if(B.getFirst()>=x) B.addFirst(x);
        }
        */
        if(B.isEmpty()||B.getFirst()>=x) B.addFirst(x);
        
    }
    
    public void pop() {
        if(A.removeLast().equals(B.peek())) B.removeFirst();

    }
    
    public int top() {//top实际上是查看栈顶的元素，并没有删除元素，注意理解题目
        return A.getLast();


    }
    
    public int min() {//min实际也没有删除元素
        return B.getFirst();

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
 
 三、1.两数字和
 
 coding:
 
 class Solution {
    public int[] twoSum(int[] nums, int target) {
        //对数组排序
        Arrays.sort(nums);
        int [] res=new int[2];
        //双指针
        int left=0;
        int right=nums.length-1;
        while(left<right){
            if(nums[left]+nums[right]>target) right--;
            else if(nums[left]+nums[right]<target) left++;
            else {
                res[0]=left;
                res[1]=right;
            }
        }
        return res;
    }
}

上述方法显示超时

method 2:

class Solution {
    public int[] twoSum(int[] nums, int target) {
        //利用HashMap存储数据
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])) return new int[] {map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int [2];
    }
}

