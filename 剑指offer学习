一、剑指 Offer 09. 用两个栈实现队列

coding:
class CQueue {
    //利用linkedList充当栈
    LinkedList<Integer> A,B;
    public CQueue() {
        A=new LinkedList<Integer>();
        B=new LinkedList<Integer>();
        //new 对象构造A,B两个实例，A为主栈，B为辅助栈           
    }
    
    public void appendTail(int value) {
        A.add(value);//直接在主栈尾部插入元素实现队列尾部插入整数

    }
    
    public int deleteHead() {
        //当辅助栈还有整数时，删除辅助栈的数
        //当辅助栈没有了，需要将A的首位转移到B的末尾
        //当主栈没有了，所以队列没有元素了，返回-1
        if(!B.isEmpty()){
            return B.removeLast();
        }
        if(A.isEmpty()){
            return -1;
        }
        if(!A.isEmpty()){
            B.add(A.poll());
        }
        return B.removeFirst();
        
    }
       
}

二、剑指 Offer 30. 包含min函数的栈

coding:
class MinStack {

    /** initialize your data structure here. */
    //考虑到min()方法要求时间复杂度为O（1），使用辅助栈存储，同样使用LinkedList
    LinkedList<Integer> A,B;
    public MinStack() {
        A=new LinkedList<>();
        B=new LinkedList<>();
    }
    
    public void push(int x) {
        A.add(x);//在主栈末尾添加
        /*if(!B.isEmpty()){
            if(B.getFirst()>=x) B.addFirst(x);
        }
        */
        if(B.isEmpty()||B.getFirst()>=x) B.addFirst(x);
        
    }
    
    public void pop() {
        if(A.removeLast().equals(B.peek())) B.removeFirst();

    }
    
    public int top() {//top实际上是查看栈顶的元素，并没有删除元素，注意理解题目
        return A.getLast();


    }
    
    public int min() {//min实际也没有删除元素
        return B.getFirst();

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
 
 三、1.两数字和
 
 coding:
 
 class Solution {
    public int[] twoSum(int[] nums, int target) {
        //对数组排序
        Arrays.sort(nums);
        int [] res=new int[2];
        //双指针
        int left=0;
        int right=nums.length-1;
        while(left<right){
            if(nums[left]+nums[right]>target) right--;
            else if(nums[left]+nums[right]<target) left++;
            else {
                res[0]=left;
                res[1]=right;
            }
        }
        return res;
    }
}

上述方法显示超时

method 2:

class Solution {
    public int[] twoSum(int[] nums, int target) {
        //利用HashMap存储数据
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])) return new int[] {map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int [2];
    }
}

四、剑指offer24 反转链表

coding:

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur=head;
        ListNode pre=null;
        while(cur!=null){
            ListNode temp=cur.next;//暂存cur的下一个节点
            cur.next=pre;//将cur指向pre
            pre=cur;//将cur赋值给pre
            cur=temp;//cur.next赋值给cur，实现节点的递增

        }
        return pre;//pre已经是之前最后的一个cur了
    }
}

五、剑指offer 06 从尾到头打印链表

coding:
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode cur=head;
        LinkedList<Integer> list=new LinkedList<>();
        while(cur!=null){
            list.addFirst(cur.val);
            cur=cur.next;
        }
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.get(i);
        }
        return res;
    }
}

该方法时间耗费较大，需要调整算法，原因在于对linkedList进行了查找，增加了时间复杂度，可修改为：
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode cur=head;
        LinkedList<Integer> list=new LinkedList<>();
        while(cur!=null){
            list.addFirst(cur.val);
            cur=cur.next;
        }
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.removeFirst();
        }
        return res;
    }
}

使用递归算法：
class Solution {
    List<Integer> list=new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        recur(head);
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.get(i);
        }
        return res;
    }
    void recur(ListNode head){
        if(head==null) return;
        recur(head.next);
        list.add(head.val);
    }
}

六、剑指offer 35复杂链表的复制

coding:

class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;//排除特殊情况
        Map<Node,Node> map=new HashMap<Node,Node>();
        Node cur=head;
        while(cur!=null){
            map.put(cur,new Node(cur.val));//建立新旧链表映射
            cur=cur.next;
        }
        cur=head;//回到头结点
        while(cur!=null){//复制next与random
            map.get(cur).next=map.get(cur.next);//新链表当前节点cur指向其cur.next
            map.get(cur).random=map.get(cur.random);
            cur=cur.next;
        }
        return map.get(head);
        
    }
}

七、左旋转字符串

coding:
class Solution {
    public String reverseLeftWords(String s, int n) {
        //return s.substring(n)+s.substring(0,n);
        //StringBuilder
        StringBuilder builder=new StringBuilder();
        for(int i=n;i<s.length();i++) builder.append(s.charAt(i));
        for(int i=0;i<n;i++) builder.append(s.charAt(i));
        return builder.toString();
    }
}

八、剑指offer 05 替换空格

coding:

class Solution {
    public String replaceSpace(String s) {
        StringBuilder res=new StringBuilder();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==' '){
                res.append("%20");
                continue;
            }
            res.append(s.charAt(i));
        }
        return res.toString();
    }
}

九、剑指offer 03 数组中重复的数字

coding:
class Solution {
    public int findRepeatNumber(int[] nums) {
        //由于数组长度为n，所有数字均在0-n-1内，因此可以考虑将数字对应数组下标，若重复则有多出来的数字
        /*
        for(int i=0;i<nums.length;i++){
            if(nums[i]==i) continue;
            else if (nums[i]==nums[nums[i]]) return nums[i];
            while(nums[i]!=i){
                int temp=nums[i];
                nums[i]=nums[nums[i]];//注意这里实际上算法有问题，nums[i]数值已调整
                nums[nums[i]]=temp;//这里并没有做到两坐标下数值交换
            }
            

        }
        return -1;
        */
        
    }
}
以上方法超出时间，两层循环O(N2）
修改为：
class Solution {
    public int findRepeatNumber(int[] nums) {
        //由于数组长度为n，所有数字均在0-n-1内，因此可以考虑将数字对应数组下标，若重复则有多出来的数字

        int i=0;
        while (i<nums.length){
            if(nums[i]==i) {
                i++;
                continue;
            }else if(nums[i]==nums[nums[i]]) return nums[i];
            int temp=nums[i];
            nums[i]=nums[temp];
            nums[temp]=temp;

        }
        return -1;
      
    }
}

十、剑指offer 53 在排序数组中查找数字
coding:
class Solution {
    public int search(int[] nums, int target) {
        //两次二分法，以目标数值为界，左边为小于目标数值的左区间，右边为大于目标数值的右区间
        int i=0;
        int j=nums.length-1;
        if(nums.length==0||target<nums[i]||target>nums[j]) return 0;
        int temp=0;
        while(i<j){//i==j时停止循环右边界
            int mid=i+(j-i+1)/2;
            if(target<nums[mid]){
                j=mid-1;
            }else{
                i=mid;
            }
        }
        if(nums[i]==target){
            temp=i;
            i=0;
            j=nums.length-1;
        }else {
            return 0;
        }
        while(i<j){//i==j时停止循环左边界
            int mid=i+(j-i)/2;
            if(target>nums[mid]){
                i=mid+1;
            }else{
                j=mid;
            }

        }
        return temp-j+1;

    }
}
