一、剑指 Offer 09. 用两个栈实现队列

coding:
class CQueue {
    //利用linkedList充当栈
    LinkedList<Integer> A,B;
    public CQueue() {
        A=new LinkedList<Integer>();
        B=new LinkedList<Integer>();
        //new 对象构造A,B两个实例，A为主栈，B为辅助栈           
    }
    
    public void appendTail(int value) {
        A.add(value);//直接在主栈尾部插入元素实现队列尾部插入整数

    }
    
    public int deleteHead() {
        //当辅助栈还有整数时，删除辅助栈的数
        //当辅助栈没有了，需要将A的首位转移到B的末尾
        //当主栈没有了，所以队列没有元素了，返回-1
        if(!B.isEmpty()){
            return B.removeLast();
        }
        if(A.isEmpty()){
            return -1;
        }
        if(!A.isEmpty()){
            B.add(A.poll());
        }
        return B.removeFirst();
        
    }
       
}

二、剑指 Offer 30. 包含min函数的栈

coding:
class MinStack {

    /** initialize your data structure here. */
    //考虑到min()方法要求时间复杂度为O（1），使用辅助栈存储，同样使用LinkedList
    LinkedList<Integer> A,B;
    public MinStack() {
        A=new LinkedList<>();
        B=new LinkedList<>();
    }
    
    public void push(int x) {
        A.add(x);//在主栈末尾添加
        /*if(!B.isEmpty()){
            if(B.getFirst()>=x) B.addFirst(x);
        }
        */
        if(B.isEmpty()||B.getFirst()>=x) B.addFirst(x);
        
    }
    
    public void pop() {
        if(A.removeLast().equals(B.peek())) B.removeFirst();

    }
    
    public int top() {//top实际上是查看栈顶的元素，并没有删除元素，注意理解题目
        return A.getLast();


    }
    
    public int min() {//min实际也没有删除元素
        return B.getFirst();

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
