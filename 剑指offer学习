一、剑指 Offer 09. 用两个栈实现队列

coding:
class CQueue {
    //利用linkedList充当栈
    LinkedList<Integer> A,B;
    public CQueue() {
        A=new LinkedList<Integer>();
        B=new LinkedList<Integer>();
        //new 对象构造A,B两个实例，A为主栈，B为辅助栈           
    }
    
    public void appendTail(int value) {
        A.add(value);//直接在主栈尾部插入元素实现队列尾部插入整数

    }
    
    public int deleteHead() {
        //当辅助栈还有整数时，删除辅助栈的数
        //当辅助栈没有了，需要将A的首位转移到B的末尾
        //当主栈没有了，所以队列没有元素了，返回-1
        if(!B.isEmpty()){
            return B.removeLast();
        }
        if(A.isEmpty()){
            return -1;
        }
        if(!A.isEmpty()){
            B.add(A.poll());
        }
        return B.removeFirst();
        
    }
       
}

二、剑指 Offer 30. 包含min函数的栈

coding:
class MinStack {

    /** initialize your data structure here. */
    //考虑到min()方法要求时间复杂度为O（1），使用辅助栈存储，同样使用LinkedList
    LinkedList<Integer> A,B;
    public MinStack() {
        A=new LinkedList<>();
        B=new LinkedList<>();
    }
    
    public void push(int x) {
        A.add(x);//在主栈末尾添加
        /*if(!B.isEmpty()){
            if(B.getFirst()>=x) B.addFirst(x);
        }
        */
        if(B.isEmpty()||B.getFirst()>=x) B.addFirst(x);
        
    }
    
    public void pop() {
        if(A.removeLast().equals(B.peek())) B.removeFirst();

    }
    
    public int top() {//top实际上是查看栈顶的元素，并没有删除元素，注意理解题目
        return A.getLast();


    }
    
    public int min() {//min实际也没有删除元素
        return B.getFirst();

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
 
 三、1.两数字和
 
 coding:
 
 class Solution {
    public int[] twoSum(int[] nums, int target) {
        //对数组排序
        Arrays.sort(nums);
        int [] res=new int[2];
        //双指针
        int left=0;
        int right=nums.length-1;
        while(left<right){
            if(nums[left]+nums[right]>target) right--;
            else if(nums[left]+nums[right]<target) left++;
            else {
                res[0]=left;
                res[1]=right;
            }
        }
        return res;
    }
}

上述方法显示超时

method 2:

class Solution {
    public int[] twoSum(int[] nums, int target) {
        //利用HashMap存储数据
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])) return new int[] {map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int [2];
    }
}

四、剑指offer24 反转链表

coding:

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur=head;
        ListNode pre=null;
        while(cur!=null){
            ListNode temp=cur.next;//暂存cur的下一个节点
            cur.next=pre;//将cur指向pre
            pre=cur;//将cur赋值给pre
            cur=temp;//cur.next赋值给cur，实现节点的递增

        }
        return pre;//pre已经是之前最后的一个cur了
    }
}

五、剑指offer 06 从尾到头打印链表

coding:
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode cur=head;
        LinkedList<Integer> list=new LinkedList<>();
        while(cur!=null){
            list.addFirst(cur.val);
            cur=cur.next;
        }
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.get(i);
        }
        return res;
    }
}

该方法时间耗费较大，需要调整算法，原因在于对linkedList进行了查找，增加了时间复杂度，可修改为：
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode cur=head;
        LinkedList<Integer> list=new LinkedList<>();
        while(cur!=null){
            list.addFirst(cur.val);
            cur=cur.next;
        }
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.removeFirst();
        }
        return res;
    }
}

使用递归算法：
class Solution {
    List<Integer> list=new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        recur(head);
        int [] res=new int [list.size()];
        for(int i=0;i<res.length;i++){
            res[i]=list.get(i);
        }
        return res;
    }
    void recur(ListNode head){
        if(head==null) return;
        recur(head.next);
        list.add(head.val);
    }
}

六、剑指offer 35复杂链表的复制

coding:

class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;//排除特殊情况
        Map<Node,Node> map=new HashMap<Node,Node>();
        Node cur=head;
        while(cur!=null){
            map.put(cur,new Node(cur.val));//建立新旧链表映射
            cur=cur.next;
        }
        cur=head;//回到头结点
        while(cur!=null){//复制next与random
            map.get(cur).next=map.get(cur.next);//新链表当前节点cur指向其cur.next
            map.get(cur).random=map.get(cur.random);
            cur=cur.next;
        }
        return map.get(head);
        
    }
}

七、左旋转字符串

coding:
class Solution {
    public String reverseLeftWords(String s, int n) {
        //return s.substring(n)+s.substring(0,n);
        //StringBuilder
        StringBuilder builder=new StringBuilder();
        for(int i=n;i<s.length();i++) builder.append(s.charAt(i));
        for(int i=0;i<n;i++) builder.append(s.charAt(i));
        return builder.toString();
    }
}

八、剑指offer 05 替换空格

coding:

class Solution {
    public String replaceSpace(String s) {
        StringBuilder res=new StringBuilder();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==' '){
                res.append("%20");
                continue;
            }
            res.append(s.charAt(i));
        }
        return res.toString();
    }
}

九、剑指offer 03 数组中重复的数字

coding:
class Solution {
    public int findRepeatNumber(int[] nums) {
        //由于数组长度为n，所有数字均在0-n-1内，因此可以考虑将数字对应数组下标，若重复则有多出来的数字
        /*
        for(int i=0;i<nums.length;i++){
            if(nums[i]==i) continue;
            else if (nums[i]==nums[nums[i]]) return nums[i];
            while(nums[i]!=i){
                int temp=nums[i];
                nums[i]=nums[nums[i]];//注意这里实际上算法有问题，nums[i]数值已调整
                nums[nums[i]]=temp;//这里并没有做到两坐标下数值交换
            }
            

        }
        return -1;
        */
        
    }
}
以上方法超出时间，两层循环O(N2）
修改为：
class Solution {
    public int findRepeatNumber(int[] nums) {
        //由于数组长度为n，所有数字均在0-n-1内，因此可以考虑将数字对应数组下标，若重复则有多出来的数字

        int i=0;
        while (i<nums.length){
            if(nums[i]==i) {
                i++;
                continue;
            }else if(nums[i]==nums[nums[i]]) return nums[i];
            int temp=nums[i];
            nums[i]=nums[temp];
            nums[temp]=temp;

        }
        return -1;
      
    }
}

十、剑指offer 53 在排序数组中查找数字
coding:
class Solution {
    public int search(int[] nums, int target) {
        //两次二分法，以目标数值为界，左边为小于目标数值的左区间，右边为大于目标数值的右区间
        int i=0;
        int j=nums.length-1;
        if(nums.length==0||target<nums[i]||target>nums[j]) return 0;
        int temp=0;
        while(i<j){//i==j时停止循环右边界
            int mid=i+(j-i+1)/2;
            if(target<nums[mid]){
                j=mid-1;
            }else{
                i=mid;
            }
        }
        if(nums[i]==target){
            temp=i;
            i=0;
            j=nums.length-1;
        }else {
            return 0;
        }
        while(i<j){//i==j时停止循环左边界
            int mid=i+(j-i)/2;
            if(target>nums[mid]){
                i=mid+1;
            }else{
                j=mid;
            }

        }
        return temp-j+1;

    }
}

十一、剑指offer 53 0-n-1中缺失的数字
coding:
class Solution {
    public int missingNumber(int[] nums) {
        //一次二分法，以目标数值为界，左边为数组下标与值相等的左区间，右边为数组下标小于目标数值的右区间
        int i=0;
        int j=nums.length-1;
        while(i<=j){//i>j时停止循环
            int mid=i+(j-i)/2;
            if(mid==nums[mid]){
                i=mid+1;
            }else{
                j=mid-1;
            }
        }
        
        return i;
    }
}

十二、剑指offer 04 二维数组中的查找
coding:
//参考题解的思路，类似二叉搜索树
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        //以左下角为基准点
        int line=matrix.length-1;
        int column=0;
        while(line>=0&&column<matrix[0].length){//在自己写的过程中将&&写成了||，实际情况只有当两者均满足时才能继续循环
            if(target>matrix[line][column]){
                column++;
            }else if(target<matrix[line][column]){
                line--;
            }else{
                return true;
            }
        }
        return false;
    }
}

十三、剑指offer 11 旋转数组的最小数字
coding:

class Solution {
    public int minArray(int[] numbers) {
        //二分法，左区间为升序数组，最后一位为原数组最大值，右区间也为升序数组，第一位即为数组最小值
        if(numbers.length==0) return 0;
        if(numbers.length==1) return numbers[0];

        int left=0;
        int len=numbers.length;
        int right=len-1;
        while(left<right){//当left=right时跳出循环
            int mid=left+(right-left)/2;
            //如果mid>right,说明mid当前在左区间，目标值下标必然大于mid
            //如果mid>right，说明mid当前在右区间，目标值下标小于等于mid
            //如果Mid=right，说明数组只有两个数，目标值下标小于等于mid(这里思路有问题，因为数组中存在重复值)
            if(numbers[mid]>numbers[right]){
                left=mid+1;
            }else if(numbers[mid]<numbers[right]){
                right=mid;
            }else{
                right--;//想法很巧妙，缩小搜索区间
            }

        }
        return numbers[left];

    }
}

十四、剑指offer 50 第一个只出现一次的字符
coding:
class Solution {
    public char firstUniqChar(String s) {
        //利用HashMap记录
        Map<Character,Boolean>map=new HashMap<>();//自己思维混乱，没想出来，参考题解
        char [] ch=s.toCharArray();
        for(int i=0;i<ch.length;i++){
            map.put(ch[i],!map.containsKey(ch[i]));          
        }
        for(int i=0;i<ch.length;i++){
            if(map.get(ch[i])) return ch[i];
        }
        return ' ';
    }
}

十五、剑指offer32-1 从上到下打印二叉树
coding:
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root==null) return new int[0];
        LinkedList<TreeNode> list=new LinkedList<>();//利用LinkedList双端队列的特性存储节点，这一步忘记了，查看了参考题解
        list.add(root);
        List<Integer> res=new ArrayList<>();//记录结果的列表
        while(!list.isEmpty()){
            TreeNode cur=list.poll();
            res.add(cur.val);
            if(cur.left!=null) list.add(cur.left);
            if(cur.right!=null) list.add(cur.right);
        }
        int [] out=new int[res.size()];
        for(int i=0;i<out.length;i++){
            out[i]=res.get(i);
        }
        return out;
    }
}

十六、剑指offer32-2，从上到下打印二叉树
coding:
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<>();
        List<List<Integer>> res=new ArrayList<>();//参考了题解
        LinkedList<TreeNode> list=new LinkedList<>();
        list.add(root);
        while(!list.isEmpty()){
            List<Integer> temp=new ArrayList<>();//将每行的元素存储在temp中
            for(int i=list.size();i>0;i--){//初始化循环式i已定，因此循环次数已定，即使因为添加cur.left/right而导致List长度发生了变化
                TreeNode cur=list.poll();
                temp.add(cur.val);
                if(cur.left!=null) list.add(cur.left);
                if(cur.right!=null) list.add(cur.right);
            }
            res.add(temp);
        }
        return res;
    }
}

十七、剑指offer32-3 从上到下打印二叉树
coding:
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<>();
        List<List<Integer>> res=new ArrayList<>();
        LinkedList<TreeNode> list=new LinkedList<>();
        list.add(root);
        int flag=0;
        while(!list.isEmpty()){
            LinkedList<Integer> temp=new LinkedList<>();//将每行的元素存储在temp中
            for(int i=list.size();i>0;i--){//初始化循环式i已定，因此循环次数已定，即使因为添加cur.left/right而导致List长度发生了变化
                if(flag%2==0){
                    TreeNode cur=list.poll();
                    temp.addLast(cur.val);
                    if(cur.left!=null) list.add(cur.left);
                    if(cur.right!=null) list.add(cur.right);
                }else{
                    TreeNode cur=list.poll();
                    temp.addFirst(cur.val);
                    if(cur.left!=null) list.add(cur.left);
                    if(cur.right!=null) list.add(cur.right);
                }
                
            }
            flag++;
            res.add(temp);
        }
        return res;
    }
}

